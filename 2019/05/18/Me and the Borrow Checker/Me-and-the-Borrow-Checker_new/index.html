<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Rust的Borrow Checker · 取何名字好呢</title><meta name="description" content="Rust的Borrow Checker - hch12907"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="取何名字好呢"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/hch12907" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Rust的Borrow Checker</h1><div class="post-info">May 18, 2019</div><div class="post-content"><p>距离Rust 1.0发布也有几年了。从最初的0.x版本，2015年的1.0版本……乃至现在，Rust作为一门编程语言也经过了不少大刀阔斧的改革。当然，无论Rust怎么发展，它始终抱着一种理念——Guaranteed Memory Safety（内存安全性的保证）。说到内存安全，相信大家也不会陌生吧。下面就简单说明一下内存安全是什么，如果想跳过请点<a href="#rust-hist">这里</a>。</p>
<p>现在假设有一段代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obj* obj = <span class="keyword">new</span> Obj();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj-&gt;result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;result; <span class="comment">// 问：该程序将返回什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终退出状态会是什么呢？0，还是1,还是10086？</p>
<p><br></p>
<p>嗯，其实上述程序的返回码是<strong>无法肯定</strong>的。C/C++标准称之为Undefined Behaviour（未定义行为）。<br>毕竟，当一个物件被摧毁时，鬼知道那块内存区域里所储存的是<code>0x0000000</code>还是<code>0xDEADBEEF</code>还是<code>0xCCCCCCCC</code>啊！说不定这块区域已经被其他物件占用了呢？如果稍改代码，在<code>delete obj</code>后面添加一句<code>obj-&gt;do_something()</code>，要是<code>obj</code>之前所占用的区域已经被其它物件使用了，那么这个<code>do_something()</code>说不定会导致程序运作非正常化，亦或者直接导致segfault发生。</p>
<p>笔者给的这个例子是已经被简化过了的。在实际项目中，这种 use-after-free（删除后仍使用）的情况比比皆是。有些时候它们特难找，就连能不能重现也是个难题。</p>
<p><strong>内存安全要阻止的，正是这类事件的发生。</strong></p>
<p><br></p>
<h2 id="浅谈Rust的历史"><a href="#浅谈Rust的历史" class="headerlink" title="浅谈Rust的历史 "></a>浅谈Rust的历史 <a name="rust-hist"></a></h2><p>现今，Rust为了确保内存安全，使用了<strong>Borrow Checker</strong>，在编译时静态检查物件在使用前是否存在。其实，在此之前，Rust曾有一段时间是有使用<strong>垃圾回收器</strong>（Garbage Collector）的。大概Rust 0.5那样的时候吧，当时才2013年。</p>
<p>Rust 0.5与大部分语言不同，拥有<em>两种</em>（两种！）堆区（heap），一个是被垃圾回收器管理的（类似Java、C#的堆），另一个是由RAII<a href="#ref-1">[1]</a><a name="ref-1-origin"></a>管理的（类似C++的<code>std::unique_ptr</code>）。<code>@u32</code>、<code>@Object</code>等类型被称为<strong>Managed Pointer</strong>（托管指针？就这么翻译吧），顾名思义是由垃圾回收器托管的；<code>~u32</code>、<code>~Object</code>等类型则被称为<strong>Owned Box</strong>（即大家现在认识的<code>Box&lt;T&gt;</code>），是由RAII或程序员手动管理的。</p>
<p>以下为Rust 0.5代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: @int = @<span class="number">10</span>; <span class="comment">// 指针一枚，所指向的区域储存着10这个整数</span></span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// *复制* 这枚指针到 b 去</span></span><br><span class="line"><span class="comment">// 数值的摧毁时间由垃圾回收器决定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: ~int = ~<span class="number">15</span>; <span class="comment">// 指针一枚，所指向的区域储存着15这个整数</span></span><br><span class="line"><span class="keyword">let</span> y = x; <span class="comment">// *移动* 这枚指针到 y 去</span></span><br><span class="line"><span class="keyword">let</span> z = x; <span class="comment">// 编译错误！x 已经被移动到 y 去了（是不是想起borrow checker了呢？）</span></span><br><span class="line"><span class="keyword">let</span> z = copy x; <span class="comment">// 编译通过。这里与现代Rust的 x.clone() 相等。</span></span><br><span class="line"><span class="comment">// 指针生命周期结束时，其数值也将一并被摧毁；类似C++的std::unique_ptr以及现代Rust的Box&lt;T&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，后来发生了什么大家都知道——垃圾回收被移除了，Rust彻底改用RAII作为管理内存的方法。至于为什么，主要有以下几点：</p>
<ul>
<li>垃圾回收器本身有一定的性能与空间开销，而Rust是个系统编程语言（system programming language），使用垃圾回收器与其理念不符。</li>
<li>降低入门难度，改善学习曲线；C/C++并没有<code>@T</code>/<code>~T</code>这种东西，因此程序员第一次遇见这种语法时可能会有所误会。</li>
<li>两个堆区大大增加了程序复杂度。</li>
<li>程序员不清楚要在什么情况下使用<code>@T</code>，什么情况下使用<code>~T</code>；真正需要用到垃圾回收的场景不多，将其保留下来没有意义。</li>
</ul>
<h2 id="Rust与Borrow-Checker"><a href="#Rust与Borrow-Checker" class="headerlink" title="Rust与Borrow Checker"></a>Rust与Borrow Checker</h2><p>Rust之所以能在编译时确保内存安全，正是因为它有borrow checker（借用检测器？）这一工具。要了解Borrow checker是什么，得先知道<strong>lifetime</strong>（生命周期）、<strong>borrowing</strong>（借用）、<strong>reference</strong>（引用）、<strong>ownership</strong>（拥有权）这几种概念才行。</p>
<h4 id="Lifetime-生命周期"><a href="#Lifetime-生命周期" class="headerlink" title="Lifetime 生命周期"></a>Lifetime 生命周期</h4><p>每样东西都有自己的寿命，对吧？程序里的物件也差不多，它在需要时被创造，用完后就被摧毁。笔者在上面说过了，在物件被摧毁后使用该物件是编程的大忌，而borrow checker的工作，则是保证物件被摧毁后不再被人使用。举个例子吧，以下代码将无法通过borrow checker，也因此无法被编译出来。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Object::new(); <span class="comment">// 创造物件</span></span><br><span class="line">    destroy(a); <span class="comment">// 摧毁物件</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a.foo); <span class="comment">// 尝试使用物件（编译失败，不能在物件被摧毁后使用该物件）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ownership-拥有权"><a href="#Ownership-拥有权" class="headerlink" title="Ownership 拥有权"></a>Ownership 拥有权</h4><p>在Rust里，每一样物件都会被某个变量“拥有”着。在一个变量被某个函数所使用时，那个变量的拥有权就由原函数转移到新函数身上了。</p>
<p>就拿上面那段代码做例子，此处的<code>a</code>拥有着一个<code>Object</code>。而<code>destroy(a)</code>这句就相当于把<code>a</code>的拥有权转移给<code>destroy()</code>，<code>foo()</code>也因此再也无法使用这个物件了——毕竟我们不能乱拿别人东西来用啊！此时<code>a</code>是在<code>destroy()</code>手里，你<code>foo()</code>拿来用的话那不就是偷窃了？这就是上述代码无法通过编译的原因。</p>
<p>获得了<code>a</code>的拥有权的<code>destroy()</code>可以对<code>a</code>为所欲为。在这里，<code>destroy()</code>把<code>a</code>给摧毁了。</p>
<h4 id="Borrowing-借用-以及-Reference-引用"><a href="#Borrowing-借用-以及-Reference-引用" class="headerlink" title="Borrowing 借用 以及 Reference 引用"></a>Borrowing 借用 以及 Reference 引用</h4><p>此时大家可能会问：如果说变量被其它函数使用后，拥有权就会转移到该函数身上，那么岂不是有很多代码都无法编译、不能重复使用一个数值了？说来其实也不对，因为我们可以把物件“借”给人家啊！换句话说，你可以让人家<strong>引用</strong>你的物件，那样子被转移拥有权的就是「物件的引用」<br>而不是「物件本身」了。</p>
<p>可以多次将变量借给其它函数，而且借用也会在函数返回时一并结束。<em>可是</em>，如果函数返回了一个新物件，而且该物件也借用了该变量，那么这次借用将不会结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数 （真正的定义部分忽略不写）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(a: &amp;Object) -&gt; (&amp;Object, <span class="built_in">i32</span>) &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">faz</span></span>(a: &amp;Object) -&gt; (&amp;Object, <span class="built_in">bool</span>) &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>(a: &amp;<span class="keyword">mut</span> Object) -&gt; (&amp;<span class="keyword">mut</span> Object, <span class="built_in">i32</span>) &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">baz</span></span>(a: &amp;Object) -&gt; &amp;Object &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范例1</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = Object::new(); <span class="comment">// 创建物件</span></span><br><span class="line">    <span class="keyword">let</span> f = foo(&amp;a);           <span class="comment">// 给予foo() a的引用 （通过编译）</span></span><br><span class="line">    <span class="keyword">let</span> g = faz(&amp;a);           <span class="comment">// 给予faz() a的引用 （通过编译）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范例2</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = Object::new(); <span class="comment">// 创建物件</span></span><br><span class="line">    <span class="keyword">let</span> b = bar(&amp;<span class="keyword">mut</span> a);       <span class="comment">// 给予bar() a的可变引用 （通过编译）</span></span><br><span class="line">    <span class="keyword">let</span> c = baz(&amp;a);           <span class="comment">// 给予baz() a的引用（编译失败）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者刚刚说了可以多次将变量借给其它函数，其实这仅仅才说了一半。我们可以多次将「不可变引用」借给别人，可是「可变引用」只能借给一个人。就把<code>a</code>当作是个文档吧。<code>foo()</code>、<code>faz()</code>、<code>baz()</code>拿到的都是复印出来的文档，无论对那份复印出来的文档怎么样，也无法改变原有物件。但是<code>bar()</code>可牛逼了，借来的是货真价实的<code>a</code>。那么问题来了：如果<code>bar()</code>借着<code>a</code>，那么<code>main()</code>还能复印<code>a</code>借给他人吗？</p>
<p>明显做不到。</p>
<p>而且，当一个物件被可变引用时，borrow checker不允许有其它引用存在，即便是不可变引用也不行。再次以文档为例子，如果<code>bar()</code>把<code>a</code>改变了，那么其他函数所拿着的复印版<code>a</code>不就和原有<code>a</code>不一样了吗？那样子此时它们手上拿着的，还是<code>a</code>吗？</p>
<p>其实，在范例2里，要是我们把代码改改，删掉<code>let b =</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = Object::new(); <span class="comment">// 创建物件</span></span><br><span class="line">    bar(&amp;<span class="keyword">mut</span> a);               <span class="comment">// 给予bar() a的可变引用</span></span><br><span class="line">    <span class="keyword">let</span> c = baz(&amp;a);           <span class="comment">// 给予bar() a的不可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后试试编译一下……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No compilation error. Exit status 0.</span><br></pre></td></tr></table></figure>
<p><img src="jingya.jpg" alt="我去这怎么可能？！"></p>
<p>诶？怎么编译就通过了？其实是这样的：</p>
<ul>
<li><code>bar()</code>返回的<code>b</code>依然借着<code>a</code></li>
<li><code>b</code>的生命周期一直延伸到作用域结束为止</li>
<li><code>baz()</code>要不可变地引用<code>a</code></li>
<li><code>baz()</code>被调用时<code>b</code>还存在着，而且<code>b</code>正在（可变地）引用着<code>a</code></li>
<li>borrow checker要求「只能有一个可变引用」或者「多个不可变引用」，故报错</li>
</ul>
<p>而当我们把<code>let b</code>移除掉的时候，<code>bar()</code>的借用在返回时就结束了——<strong><code>let b</code>把<code>bar()</code>的借用期延长了</strong>。</p>
<p>理解了这些概念，也就了解了borrow checker是什么。其实，borrow checker遵循的规则很简单：</p>
<ol>
<li>物件不能同时被两个地方更改</li>
<li>物件被更改时，其他地方不能使用它</li>
<li>物件被摧毁后，就再也无法被使用（转移拥有权后，该物件对原拥有者而言，和被摧毁无异）</li>
</ol>
<p><br></p>
<h2 id="生命周期-——-Non-lexical-Lifetime-非作用域生命周期"><a href="#生命周期-——-Non-lexical-Lifetime-非作用域生命周期" class="headerlink" title="生命周期++ —— Non-lexical Lifetime 非作用域生命周期"></a>生命周期++ —— Non-lexical Lifetime 非作用域生命周期</h2><p>好，之前我们说过了，<em>一个引用在其作用域结束前都会一直存在着，结果就是生命周期被绑定在作用域上面了。</em><br>这规则看起来没问题，可是其缺点却是致命的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;, x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获得字典里的foo</span></span><br><span class="line">    <span class="keyword">match</span> map.get(<span class="string">"foo"</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有，就打印出来它的值</span></span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> val) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, val), </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有，则为字典添加(foo: x)。</span></span><br><span class="line">        <span class="literal">None</span> =&gt; map.insert(<span class="string">"foo"</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看似就只是普普通通的一段代码，不可能会有什么幺蛾子出现，也不存在内存安全问题。</p>
<p><br></p>
<p>结果borrow checker就报错了。</p>
<blockquote>
<p>在<code>map.get(&quot;foo&quot;)</code>这里, map被match借走了。而<code>map.insert()</code>这段代码还在match的作用域内，因此在<code>insert()</code>被调用的时候<br>map依然正在被match借着。显然，<code>None =&gt; {...}</code> 是没有用到<code>map.get()</code>的值的，所以这次报错是个误报。</p>
</blockquote>
<p>为了解决这个问题，开发者们搞出来了<strong>Non-Lexical Lifetime （简称NLL）</strong>这个东西。非作用域生命周期，不被绑定在某个作用域的生命周期。<br>本质上是允许物件、引用的生命周期在一定条件下被拉长、缩短，而非将其与作用域的生命周期等同。比如说在确认物件后期不再被使用的情况下，缩短其生命周期。（如果你不要用同学的东西了，却还一直借着他的东西直到放学，不就是在耍赖么）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = Object::new();</span><br><span class="line">    <span class="keyword">let</span> b = bar(&amp;<span class="keyword">mut</span> a);</span><br><span class="line">    <span class="keyword">let</span> c = baz(&amp;a);     <span class="comment">// 没事，反正`b`已经没用了，缩短`b`的生命周期呗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;, x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获得字典里的foo</span></span><br><span class="line">    <span class="keyword">match</span> map.get(<span class="string">"foo"</span>) &#123;      <span class="comment">// -----------------</span></span><br><span class="line">        <span class="comment">// 如果有，就打印出来它的值                    |</span></span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> val) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, val), <span class="comment">// &lt;-- match把引用转移给 Some(...) =&gt; &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有，则为字典添加(foo: x)。       </span></span><br><span class="line">        <span class="literal">None</span> =&gt; map.insert(<span class="string">"foo"</span>, x)          <span class="comment">//  虽然在match的作用域内，可是没用到map.get()</span></span><br><span class="line">                                              <span class="comment">//  的值，所以缩短其生命周期，以此通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h3><p><a name="ref-1"></a>[1]: RAII：Resource Acquisition Is Initialization<a href="#ref-1-origin">↑</a></p>
</div></article></div></main><footer><div class="paginator"></div><div class="copyright"><p>© 2017 - 2019 <a href="http://yoursite.com">hch12907</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>