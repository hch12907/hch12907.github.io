<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Rust的Borrow Checker · 取何名字好呢</title><meta name="description" content="Rust的Borrow Checker - hch12907"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="取何名字好呢"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/hch12907" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Rust的Borrow Checker</h1><div class="post-info">Sep 23, 2017</div><div class="post-content"><p>Rust是一门挺新的语言。它的v1.0版本在大概2015年发布——真的挺新的，不是吗？它雄心勃勃，声称它是一门<strong>安全的语言</strong>，可以阻止segfault的发生。今天我就不谈些什么，就说说让Rust有这个底气，说这种话的家伙 —— Borrow Checker（借用检查器）。<br><a id="more"></a><br>说Borrow checker（借用检查器）之前，我们要知道——什么是借用。</p>
<h1 id="借用？"><a href="#借用？" class="headerlink" title="借用？"></a>借用？</h1><p>Rust是一门很明确而不含糊的语言。这话是什么意思呢？我是个喜欢上例子的人，就给俩例子吧：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    int x = <span class="number">1000</span>;</div><div class="line">    int y = x;</div><div class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y;</div><div class="line">    <span class="comment">// 输出： 1000 1000</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">1000</span>;</div><div class="line">    <span class="keyword">let</span> y = x;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, x, y);</div><div class="line">    <span class="comment">// 编译错误：Use of moved value: `x`</span></div><div class="line">    <span class="comment">// x的值已被移动去y，因此x的值不能再次被使用。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信大家都能理解上面两段小代码。</p>
<p>回归正题：<strong><em>为什么Rust是一门明确而不含糊的语言？</em></strong><br>根据以上代码，C++的代码成功编译了，而Rust的却没，可是这俩代码是一致的！为什么？<br>答案很简单： Rust不懂得去猜测别人要他干什么，<strong>它希望别人能够明确地(explicitly)告诉他要干什么</strong>，如果人们不仔细说好来，它可能会少做一个步骤。</p>
<blockquote>
<p>Rust在绝大多数情况下，都不会主动复制变量，因此Rust其实只是把<code>x</code>的值移动到了<code>y</code>上。以上的代码，你只要把<code>y=x</code>修改成<code>y=x.clone()</code>就能成功进行编译了。<br>而C++则在<code>y = x</code>的时候（隐约地）复制了x的值。</p>
<p><strong>而且，Rust并不是所有东西都能被<code>clone()</code>的。比如说，要使一个struct可复制，程序员必须为该struct实现<code>Clone</code>。</strong><br><strong>虽然听起来很麻烦，可是Rust提供了<code>derive</code>，也就是说只需加一行代码，编译器便会为其自动实现Clone。</strong></p>
</blockquote>
<p>既然知道它并不会随意复制变量，并且不是所有东西都可复制，程序员就只剩两个选项了：干脆直接移动（上面范例已经显示出来了这点），和 <strong>借用(borrowing)</strong>。<br><strong>借用</strong> 这个概念，顾名思义，就是把一个变量的值<strong>借</strong>给其他东西（如函数或者其它变量）。实际上，它和C++的<code>reference</code>相似，只是玩得更嗨：Rust的borrowing/reference有lifetime（即生命周期）这个概念。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">10</span>; </div><div class="line">    process(x); <span class="comment">// 这里x的值已经被移动到process这个函数里。</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x); <span class="comment">// 编译错误：x的值已被移动。</span></div><div class="line"></div><div class="line">    <span class="comment">// 改一下代码……为x加个&amp;。</span></div><div class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</div><div class="line">    process(&amp;x); <span class="comment">// 让process接受 &amp;i32 而不是 i32</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x); <span class="comment">// 编译通过了。为什么加个&amp;就通过了呢？</span></div><div class="line"></div><div class="line">    <span class="comment">//再改一下……</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>; <span class="comment">// 注意mut这个关键词：它使x这个变量可变。</span></div><div class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x; <span class="comment">// 借x给y用。y可以改变x的值。</span></div><div class="line">    process(&amp;x); <span class="comment">// 又编译失败了！不是说好了借用就可以了吗？</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码，表现出来了Rust的（官方）卖点：借用（borrowing）、生命周期（lifetime）、借用检查器（borrow checker）。</p>
<blockquote>
<p>在Rust中，<code>&amp;x</code>即<code>借x</code>；<code>接受&amp;i32</code>就意味着<code>接受借来的i32</code></p>
</blockquote>
<p>首先，谈谈为什么第二段代码会编译成功。 在<code>process(&amp;x)</code>，x只是暂时被<code>main</code>借给了<code>process</code>，<code>process</code>完成过后，又将它的值还回给<code>main</code>。</p>
<blockquote>
<p>这就像你把你的铅笔借给了同桌，而当你的同桌写完作业后，又将它还回给你。而在这段代码的第一段中，犹如你把你的笔送给了同桌，而你过后又向同桌要回（此时已经是他的）笔，这不行啊你说是不是。</p>
</blockquote>
<p><br></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>再谈谈，为什么第三段代码失败了：这就要扯到 <code>生命周期</code> 这回事了。<br>当你借笔给同桌的时候，他总不可以一直借着不还，对吧？那种事情太损了。而<code>生命周期</code>就是变量被借走的时间。再看看刚才代码的错误部分：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</div><div class="line">process(&amp;x);</div></pre></td></tr></table></figure></p>
<p>第一行：y 借着 x, y（即&amp;mut x）的生命周期开始。<br>第二行：此时 y 还在借着 &amp;x ，你能把已经被借走的东西再借给人吗？你的变量可没有分身术，借用检查器发现到这里有问题，因此编译错误了。</p>
<p><br><br>那么你说吧，要怎么控制生命周期呢？简单，靠 <code>scope</code>（作用域） 这个东西。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">100</span>;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> y = &amp;x;</div><div class="line">&#125;</div><div class="line">process(&amp;x); <span class="comment">// 编译成功！可是y不是借走了x吗？</span></div></pre></td></tr></table></figure></p>
<p>嗯，这个我相信有经验的程序员已经想到了：y在作用域结束后就没了，被删了，没人去引用<code>x</code>了。也就是说，我们又能愉快的使用<code>x</code>了。</p>
<p>这个就是Rust的借用系统的大约基本知识。</p>
<p><br></p>
<h1 id="我和Borrow-check打交道的时间"><a href="#我和Borrow-check打交道的时间" class="headerlink" title="我和Borrow check打交道的时间"></a>我和Borrow check打交道的时间</h1><p>说粉到深处自然黑，我使用了Rust好一段时间，和它打的交道多起来了，也对它的borrow checker所拥有的缺陷有一定认知了。</p>
<p>Borrow check是个很有理想的机制 —— 迈过它的学习曲线后，你就有如写那些拥有垃圾回收机制的语言的开发效率，同时也少了垃圾回收机制所带来的性能惩罚。而在这一切的前提：迈过那根学习曲线。对于一些人而言，这个曲线可能很容易就能被迈过；可是就单对笔者而言，这可不是一条好迈的线。我用了1个月，写了三个项目过后才开始抓住了borrow check的<strong>认知</strong>以及<strong>坑</strong>。</p>
<p><br></p>
<h4 id="Borrow-checker的缺陷"><a href="#Borrow-checker的缺陷" class="headerlink" title="Borrow checker的缺陷"></a>Borrow checker的缺陷</h4><p>就用以下，经常有人使用的的Map（字典、Dictionary…… 无论什么名字，你懂就行了）来举例子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;, x: <span class="built_in">i32</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 尝试获得字典里的foo</span></div><div class="line">    <span class="keyword">match</span> map.get(<span class="string">"foo"</span>) &#123;</div><div class="line">        <span class="comment">// 如果有，就打印出来它的值</span></div><div class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> val) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, val), </div><div class="line"></div><div class="line">        <span class="comment">// 如果没有，则为字典添加foo，foo的值是x。</span></div><div class="line">        <span class="literal">None</span> =&gt; map.insert(<span class="string">"foo"</span>, x)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个代码是不是看起来天真无邪，并且可以通过呢？然而……它不行。</p>
<blockquote>
<p>在<code>map.get(&quot;foo&quot;)</code>, map就被match借走了。而<code>map.insert</code>这段代码还在match的作用域内，因此在insert的时候<br>map依然正在被match借着。</p>
</blockquote>
<p>这个是borrow checker的严重缺陷：<br><em>一个引用的生命周期，在引用被摧毁前都会一直存在着，即便引用只在那段代码运行后就没用了。</em><br>一个引用在作用域结束前都会一直存在着，结果就是生命周期被绑定在作用域上面了。<br>就如上面的match，map的值在None分支上一直没被用到（也就是说<strong>理论上</strong>map没被借走），却因为生命周期扩展到整个作用域，而无法被insert。</p>
<p>这段代码的解决方法之一就是：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;, x: <span class="built_in">i32</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 尝试获得字典里的foo</span></div><div class="line">    <span class="keyword">match</span> map.get(<span class="string">"foo"</span>) &#123;</div><div class="line">        <span class="comment">// 如果有，就打印出来它的值并且提早返回</span></div><div class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> val) =&gt; &#123; </div><div class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, val);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;, </div><div class="line"></div><div class="line">        <span class="comment">// 如果没有，则结束match。</span></div><div class="line">        <span class="literal">None</span> =&gt; ()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    map.insert(<span class="string">"foo"</span>, x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然可行，不过这个代码不只是<strong>可读性</strong>下降了；其<strong>性能</strong>也因为优化器无法正常优化该代码而受到影响。<br>既然古人曾说过<em>穷则变，变则通</em>，遇到这个困境的时候，肯定就会有人提出解决方法：<strong>Non-lexical Lifetimes</strong>。</p>
<p><br></p>
<h4 id="Non-Lexical-Lifetimes"><a href="#Non-Lexical-Lifetimes" class="headerlink" title="Non-Lexical Lifetimes"></a>Non-Lexical Lifetimes</h4><p>目前Rust社区已经有人针对这个问题提出解决方案：Non-lexical Lifetimes（根据整个代码的控制流来理清其生命周期，<br>而不将生命周期绑定在作用域上）。</p>
<p>根据这个方案，borrow checker会检查变量的借用会在何时停止。因此，未来Rust可能会有以下代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">100</span>;</div><div class="line"><span class="keyword">let</span> y = &amp;x;</div><div class="line"><span class="comment">/* 对y进行工作 ... */</span></div><div class="line">process(&amp;x); <span class="comment">// 编译成功，因为y之后已经不再被使用了，也就是说x能够安全地被借走了。</span></div></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;, x: <span class="built_in">i32</span>) &#123;</div><div class="line">    <span class="comment">// 尝试获得字典里的foo</span></div><div class="line">    <span class="keyword">match</span> map.get(<span class="string">"foo"</span>) &#123;</div><div class="line">        <span class="comment">// 如果有，就打印出来它的值</span></div><div class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> val) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, val), </div><div class="line"></div><div class="line">        <span class="comment">// 此时，map的内容也没被其他人用，因此map.get的引用停留在这里了。</span></div><div class="line">        <span class="comment">// 因此，下一行代码的insert能正常通过编译。</span></div><div class="line">        <span class="literal">None</span> =&gt; map.insert(<span class="string">"foo"</span>, x)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br><br><br><br><em>最后编辑于：2018年1月6日 15:59</em></p>
</div></article></div></main><footer><div class="paginator"></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com">hch12907</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>